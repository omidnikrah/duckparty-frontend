import type { AxiosError } from 'axios';
import type { SolidMutationOptions } from '@tanstack/solid-query';
/**
 * Generated by orval v7.16.1 üç∫
 * Do not edit manually.
 * Duck Party API
 * API for Duck Party backend service
 * OpenAPI spec version: 1.0
 */

import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/solid-query";
import { useMutation, useQuery } from "@tanstack/solid-query";
import { customInstance } from "../axios-instance";
import type {
  AuthenticateRequest,
  AuthenticateRequestBody,
  AuthenticateResponse,
  CreateAnonymousUserRequest,
  DeleteDuckDuckId200,
  DeleteDuckDuckId400,
  DeleteDuckDuckId404,
  DeleteDuckDuckId500,
  DuckReactionResponse,
  DuckResponse,
  GetDucks500,
  GetLeaderboard500,
  GetUser400,
  GetUserUserIdDucks400,
  GetUserUserIdDucks500,
  GetWs400,
  PostAuth200,
  PostAuth400,
  PostAuthAnonymous400,
  PostAuthVerify400,
  PostDuck400,
  PostDuck500,
  PostDuckBody,
  PostUserSetEmail200,
  PostUserSetEmail400,
  PostUserVerifySetEmail400,
  PutDuckDuckIdReactionReaction400,
  PutDuckDuckIdReactionReaction404,
  PutDuckDuckIdReactionReaction409,
  PutDuckDuckIdReactionReaction500,
  PutUserChangeName400,
  SetEmailRequest,
  UpdateNameRequest,
  UserInfoResponse,
} from "./schemas";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Sends a one-time password (OTP) to the user's email address for authentication
 * @summary Send OTP to user email
 */
export const postAuth = (
  authenticateRequest: AuthenticateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PostAuth200>(
    {
      url: `/auth`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authenticateRequest,
      signal,
    },
    options,
  );
};

export const getPostAuthMutationOptions = <
  TError = AxiosError<PostAuth400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuth>>,
    TError,
    { data: AuthenticateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuth>>,
  TError,
  { data: AuthenticateRequest },
  TContext
> => {
  const mutationKey = ["postAuth"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuth>>,
    { data: AuthenticateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return postAuth(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuth>>
>;
export type PostAuthMutationBody = AuthenticateRequest;
export type PostAuthMutationError = PostAuth400;

/**
 * @summary Send OTP to user email
 */
export const usePostAuth = <
  TError = AxiosError<PostAuth400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuth>>,
    TError,
    { data: AuthenticateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof postAuth>>,
  TError,
  { data: AuthenticateRequest },
  TContext
> => {
  const mutationOptions = getPostAuthMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Creates an anonymous user with a display name and returns a JWT token for immediate use
 * @summary Create anonymous user and get token
 */
export const postAuthAnonymous = (
  createAnonymousUserRequest: CreateAnonymousUserRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticateResponse>(
    {
      url: `/auth/anonymous`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: createAnonymousUserRequest,
      signal,
    },
    options,
  );
};

export const getPostAuthAnonymousMutationOptions = <
  TError = AxiosError<PostAuthAnonymous400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthAnonymous>>,
    TError,
    { data: CreateAnonymousUserRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuthAnonymous>>,
  TError,
  { data: CreateAnonymousUserRequest },
  TContext
> => {
  const mutationKey = ["postAuthAnonymous"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthAnonymous>>,
    { data: CreateAnonymousUserRequest }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthAnonymous(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthAnonymousMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthAnonymous>>
>;
export type PostAuthAnonymousMutationBody = CreateAnonymousUserRequest;
export type PostAuthAnonymousMutationError = PostAuthAnonymous400;

/**
 * @summary Create anonymous user and get token
 */
export const usePostAuthAnonymous = <
  TError = AxiosError<PostAuthAnonymous400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthAnonymous>>,
    TError,
    { data: CreateAnonymousUserRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof postAuthAnonymous>>,
  TError,
  { data: CreateAnonymousUserRequest },
  TContext
> => {
  const mutationOptions = getPostAuthAnonymousMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Verifies the OTP code and returns user information along with JWT token
 * @summary Verify OTP and authenticate user
 */
export const postAuthVerify = (
  authenticateRequestBody: AuthenticateRequestBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticateResponse>(
    {
      url: `/auth/verify`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authenticateRequestBody,
      signal,
    },
    options,
  );
};

export const getPostAuthVerifyMutationOptions = <
  TError = AxiosError<PostAuthVerify400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthVerify>>,
    TError,
    { data: AuthenticateRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuthVerify>>,
  TError,
  { data: AuthenticateRequestBody },
  TContext
> => {
  const mutationKey = ["postAuthVerify"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthVerify>>,
    { data: AuthenticateRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthVerify(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthVerify>>
>;
export type PostAuthVerifyMutationBody = AuthenticateRequestBody;
export type PostAuthVerifyMutationError = PostAuthVerify400;

/**
 * @summary Verify OTP and authenticate user
 */
export const usePostAuthVerify = <
  TError = AxiosError<PostAuthVerify400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthVerify>>,
    TError,
    { data: AuthenticateRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof postAuthVerify>>,
  TError,
  { data: AuthenticateRequestBody },
  TContext
> => {
  const mutationOptions = getPostAuthVerifyMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Creates a new duck with image, name, email, and appearance data
 * @summary Create a new duck
 */
export const postDuck = (
  postDuckBody: PostDuckBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  formData.append(`image`, postDuckBody.image);
  formData.append(`name`, postDuckBody.name);
  formData.append(`appearance`, postDuckBody.appearance);

  return customInstance<DuckResponse>(
    {
      url: `/duck`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
      signal,
    },
    options,
  );
};

export const getPostDuckMutationOptions = <
  TError = AxiosError<PostDuck400 | PostDuck500>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postDuck>>,
    TError,
    { data: PostDuckBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postDuck>>,
  TError,
  { data: PostDuckBody },
  TContext
> => {
  const mutationKey = ["postDuck"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postDuck>>,
    { data: PostDuckBody }
  > = (props) => {
    const { data } = props ?? {};

    return postDuck(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostDuckMutationResult = NonNullable<
  Awaited<ReturnType<typeof postDuck>>
>;
export type PostDuckMutationBody = PostDuckBody;
export type PostDuckMutationError = PostDuck400 | PostDuck500;

/**
 * @summary Create a new duck
 */
export const usePostDuck = <
  TError = AxiosError<PostDuck400 | PostDuck500>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postDuck>>,
    TError,
    { data: PostDuckBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof postDuck>>,
  TError,
  { data: PostDuckBody },
  TContext
> => {
  const mutationOptions = getPostDuckMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Deletes a duck owned by the authenticated user
 * @summary Remove a duck
 */
export const deleteDuckDuckId = (
  duckId: number,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DeleteDuckDuckId200>(
    { url: `/duck/${duckId}`, method: "DELETE" },
    options,
  );
};

export const getDeleteDuckDuckIdMutationOptions = <
  TError = AxiosError<DeleteDuckDuckId400 | DeleteDuckDuckId404 | DeleteDuckDuckId500>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDuckDuckId>>,
    TError,
    { duckId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof deleteDuckDuckId>>,
  TError,
  { duckId: number },
  TContext
> => {
  const mutationKey = ["deleteDuckDuckId"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof deleteDuckDuckId>>,
    { duckId: number }
  > = (props) => {
    const { duckId } = props ?? {};

    return deleteDuckDuckId(duckId, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type DeleteDuckDuckIdMutationResult = NonNullable<
  Awaited<ReturnType<typeof deleteDuckDuckId>>
>;

export type DeleteDuckDuckIdMutationError =
  | DeleteDuckDuckId400
  | DeleteDuckDuckId404
  | DeleteDuckDuckId500;

/**
 * @summary Remove a duck
 */
export const useDeleteDuckDuckId = <
  TError = AxiosError<DeleteDuckDuckId400 | DeleteDuckDuckId404 | DeleteDuckDuckId500>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof deleteDuckDuckId>>,
    TError,
    { duckId: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof deleteDuckDuckId>>,
  TError,
  { duckId: number },
  TContext
> => {
  const mutationOptions = getDeleteDuckDuckIdMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Add a like or dislike reaction to a duck
 * @summary React to a duck
 */
export const putDuckDuckIdReactionReaction = (
  duckId: string,
  reaction: "like" | "dislike",
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DuckReactionResponse>(
    { url: `/duck/${duckId}/reaction/${reaction}`, method: "PUT" },
    options,
  );
};

export const getPutDuckDuckIdReactionReactionMutationOptions = <
  TError = AxiosError<| PutDuckDuckIdReactionReaction400
    | PutDuckDuckIdReactionReaction404
    | PutDuckDuckIdReactionReaction409
    | PutDuckDuckIdReactionReaction500>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
    TError,
    { duckId: string; reaction: "like" | "dislike" },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
  TError,
  { duckId: string; reaction: "like" | "dislike" },
  TContext
> => {
  const mutationKey = ["putDuckDuckIdReactionReaction"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
    { duckId: string; reaction: "like" | "dislike" }
  > = (props) => {
    const { duckId, reaction } = props ?? {};

    return putDuckDuckIdReactionReaction(duckId, reaction, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutDuckDuckIdReactionReactionMutationResult = NonNullable<
  Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>
>;

export type PutDuckDuckIdReactionReactionMutationError =
  | PutDuckDuckIdReactionReaction400
  | PutDuckDuckIdReactionReaction404
  | PutDuckDuckIdReactionReaction409
  | PutDuckDuckIdReactionReaction500;

/**
 * @summary React to a duck
 */
export const usePutDuckDuckIdReactionReaction = <
  TError = AxiosError<| PutDuckDuckIdReactionReaction400
    | PutDuckDuckIdReactionReaction404
    | PutDuckDuckIdReactionReaction409
    | PutDuckDuckIdReactionReaction500>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
    TError,
    { duckId: string; reaction: "like" | "dislike" },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
  TError,
  { duckId: string; reaction: "like" | "dislike" },
  TContext
> => {
  const mutationOptions =
    getPutDuckDuckIdReactionReactionMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Returns a list of all ducks ordered by creation date
 * @summary Get list of ducks
 */
export const getDucks = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<DuckResponse[]>(
    { url: `/ducks`, method: "GET", signal },
    options,
  );
};

export const getGetDucksQueryKey = () => {
  return [`/ducks`] as const;
};

export const getGetDucksQueryOptions = <
  TData = Awaited<ReturnType<typeof getDucks>>,
  TError = AxiosError<GetDucks500>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getDucks>>, TError, TData> & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDucksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDucks>>> = ({
    signal,
  }) => getDucks(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } ;
};

export type GetDucksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDucks>>
>;
export type GetDucksQueryError = GetDucks500;

/**
 * @summary Get list of ducks
 */

export function useGetDucks<
  TData = Awaited<ReturnType<typeof getDucks>>,
  TError = AxiosError<GetDucks500>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getDucks>>, TError, TData> & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDucksQueryOptions(options);

  const query = useQuery(() => queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the top 100 ducks sorted by rank (highest to lowest)
 * @summary Get ducks leaderboard
 */
export const getLeaderboard = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<DuckResponse[]>(
    { url: `/leaderboard`, method: "GET", signal },
    options,
  );
};

export const getGetLeaderboardQueryKey = () => {
  return [`/leaderboard`] as const;
};

export const getGetLeaderboardQueryOptions = <
  TData = Awaited<ReturnType<typeof getLeaderboard>>,
  TError = AxiosError<GetLeaderboard500>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getLeaderboard>>,
    TError,
    TData
  > & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetLeaderboardQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getLeaderboard>>> = ({
    signal,
  }) => getLeaderboard(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } ;
};

export type GetLeaderboardQueryResult = NonNullable<
  Awaited<ReturnType<typeof getLeaderboard>>
>;
export type GetLeaderboardQueryError = GetLeaderboard500;

/**
 * @summary Get ducks leaderboard
 */

export function useGetLeaderboard<
  TData = Awaited<ReturnType<typeof getLeaderboard>>,
  TError = AxiosError<GetLeaderboard500>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof getLeaderboard>>,
    TError,
    TData
  > & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetLeaderboardQueryOptions(options);

  const query = useQuery(() => queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Returns the information of the currently authenticated user
 * @summary Get current user information
 */
export const getUser = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<UserInfoResponse>(
    { url: `/user`, method: "GET", signal },
    options,
  );
};

export const getGetUserQueryKey = () => {
  return [`/user`] as const;
};

export const getGetUserQueryOptions = <
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = AxiosError<GetUser400>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetUserQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getUser>>> = ({
    signal,
  }) => getUser(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } ;
};

export type GetUserQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUser>>
>;
export type GetUserQueryError = GetUser400;

/**
 * @summary Get current user information
 */

export function useGetUser<
  TData = Awaited<ReturnType<typeof getUser>>,
  TError = AxiosError<GetUser400>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getUser>>, TError, TData> & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserQueryOptions(options);

  const query = useQuery(() => queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Updates the display name of the authenticated user
 * @summary Update user display name
 */
export const putUserChangeName = (
  updateNameRequest: UpdateNameRequest,
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<UserInfoResponse>(
    {
      url: `/user/change-name`,
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      data: updateNameRequest,
    },
    options,
  );
};

export const getPutUserChangeNameMutationOptions = <
  TError = AxiosError<PutUserChangeName400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putUserChangeName>>,
    TError,
    { data: UpdateNameRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof putUserChangeName>>,
  TError,
  { data: UpdateNameRequest },
  TContext
> => {
  const mutationKey = ["putUserChangeName"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putUserChangeName>>,
    { data: UpdateNameRequest }
  > = (props) => {
    const { data } = props ?? {};

    return putUserChangeName(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutUserChangeNameMutationResult = NonNullable<
  Awaited<ReturnType<typeof putUserChangeName>>
>;
export type PutUserChangeNameMutationBody = UpdateNameRequest;
export type PutUserChangeNameMutationError = PutUserChangeName400;

/**
 * @summary Update user display name
 */
export const usePutUserChangeName = <
  TError = AxiosError<PutUserChangeName400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putUserChangeName>>,
    TError,
    { data: UpdateNameRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof putUserChangeName>>,
  TError,
  { data: UpdateNameRequest },
  TContext
> => {
  const mutationOptions = getPutUserChangeNameMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Sends an OTP to the new email address for verification. Use /user/verify-email to verify and set the email.
 * @summary Send OTP to new email address
 */
export const postUserSetEmail = (
  setEmailRequest: SetEmailRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PostUserSetEmail200>(
    {
      url: `/user/set-email`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: setEmailRequest,
      signal,
    },
    options,
  );
};

export const getPostUserSetEmailMutationOptions = <
  TError = AxiosError<PostUserSetEmail400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserSetEmail>>,
    TError,
    { data: SetEmailRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postUserSetEmail>>,
  TError,
  { data: SetEmailRequest },
  TContext
> => {
  const mutationKey = ["postUserSetEmail"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUserSetEmail>>,
    { data: SetEmailRequest }
  > = (props) => {
    const { data } = props ?? {};

    return postUserSetEmail(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUserSetEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof postUserSetEmail>>
>;
export type PostUserSetEmailMutationBody = SetEmailRequest;
export type PostUserSetEmailMutationError = PostUserSetEmail400;

/**
 * @summary Send OTP to new email address
 */
export const usePostUserSetEmail = <
  TError = AxiosError<PostUserSetEmail400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserSetEmail>>,
    TError,
    { data: SetEmailRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof postUserSetEmail>>,
  TError,
  { data: SetEmailRequest },
  TContext
> => {
  const mutationOptions = getPostUserSetEmailMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Verifies the OTP code and sets the email address for the authenticated user. Returns updated user and new token.
 * @summary Verify email change with OTP
 */
export const postUserVerifySetEmail = (
  authenticateRequestBody: AuthenticateRequestBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticateResponse>(
    {
      url: `/user/verify-set-email`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authenticateRequestBody,
      signal,
    },
    options,
  );
};

export const getPostUserVerifySetEmailMutationOptions = <
  TError = AxiosError<PostUserVerifySetEmail400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserVerifySetEmail>>,
    TError,
    { data: AuthenticateRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postUserVerifySetEmail>>,
  TError,
  { data: AuthenticateRequestBody },
  TContext
> => {
  const mutationKey = ["postUserVerifySetEmail"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postUserVerifySetEmail>>,
    { data: AuthenticateRequestBody }
  > = (props) => {
    const { data } = props ?? {};

    return postUserVerifySetEmail(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostUserVerifySetEmailMutationResult = NonNullable<
  Awaited<ReturnType<typeof postUserVerifySetEmail>>
>;
export type PostUserVerifySetEmailMutationBody = AuthenticateRequestBody;
export type PostUserVerifySetEmailMutationError = PostUserVerifySetEmail400;

/**
 * @summary Verify email change with OTP
 */
export const usePostUserVerifySetEmail = <
  TError = AxiosError<PostUserVerifySetEmail400>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postUserVerifySetEmail>>,
    TError,
    { data: AuthenticateRequestBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof postUserVerifySetEmail>>,
  TError,
  { data: AuthenticateRequestBody },
  TContext
> => {
  const mutationOptions = getPostUserVerifySetEmailMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Returns a list of all ducks owned by the specified user, ordered by creation date
 * @summary Get list of ducks for a specific user
 */
export const getUserUserIdDucks = (
  userId: number,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<DuckResponse[]>(
    { url: `/user/${userId}/ducks`, method: "GET", signal },
    options,
  );
};

export const getGetUserUserIdDucksQueryKey = (userId?: number) => {
  return [`/user/${userId}/ducks`] as const;
};

export const getGetUserUserIdDucksQueryOptions = <
  TData = Awaited<ReturnType<typeof getUserUserIdDucks>>,
  TError = AxiosError<GetUserUserIdDucks400 | GetUserUserIdDucks500>,
>(
  userId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserUserIdDucks>>,
      TError,
      TData
    > & { queryKey: QueryKey };
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getGetUserUserIdDucksQueryKey(userId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getUserUserIdDucks>>
  > = ({ signal }) => getUserUserIdDucks(userId, requestOptions, signal);

  return {
    queryKey,
    queryFn,
    enabled: !!userId,
    ...queryOptions,
  } ;
};

export type GetUserUserIdDucksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getUserUserIdDucks>>
>;
export type GetUserUserIdDucksQueryError =
  | GetUserUserIdDucks400
  | GetUserUserIdDucks500;

/**
 * @summary Get list of ducks for a specific user
 */

export function useGetUserUserIdDucks<
  TData = Awaited<ReturnType<typeof getUserUserIdDucks>>,
  TError = AxiosError<GetUserUserIdDucks400 | GetUserUserIdDucks500>,
>(
  userId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof getUserUserIdDucks>>,
      TError,
      TData
    > & { queryKey: QueryKey };
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetUserUserIdDucksQueryOptions(userId, options);

  const query = useQuery(() => queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Establishes a WebSocket connection to receive real-time notifications when new ducks are added
 * @summary WebSocket connection for real-time duck notifications
 */
export const getWs = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<unknown>(
    { url: `/ws`, method: "GET", signal },
    options,
  );
};

export const getGetWsQueryKey = () => {
  return [`/ws`] as const;
};

export const getGetWsQueryOptions = <
  TData = Awaited<ReturnType<typeof getWs>>,
  TError = AxiosError<void | GetWs400>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getWs>>, TError, TData> & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetWsQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getWs>>> = ({
    signal,
  }) => getWs(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } ;
};

export type GetWsQueryResult = NonNullable<Awaited<ReturnType<typeof getWs>>>;
export type GetWsQueryError = void | GetWs400;

/**
 * @summary WebSocket connection for real-time duck notifications
 */

export function useGetWs<
  TData = Awaited<ReturnType<typeof getWs>>,
  TError = AxiosError<void | GetWs400>,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getWs>>, TError, TData> & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetWsQueryOptions(options);

  const query = useQuery(() => queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
