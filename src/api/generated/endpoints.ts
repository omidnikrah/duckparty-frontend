import type { SolidMutationOptions } from '@tanstack/solid-query';
/**
 * Generated by orval v7.16.1 üç∫
 * Do not edit manually.
 * Duck Party API
 * API for Duck Party backend service
 * OpenAPI spec version: 1.0
 */

import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from "@tanstack/solid-query";
import { useMutation, useQuery } from "@tanstack/solid-query";
import { customInstance } from "../axios-instance";
import type {
  AuthenticateRequest,
  AuthenticateResponse,
  DuckReactionResponse,
  DuckResponse,
  GetDucks500,
  PostAuth200,
  PostAuth400,
  PostAuthVerify400,
  PostDuck400,
  PostDuck500,
  PostDuckBody,
  PutDuckDuckIdReactionReaction400,
  PutDuckDuckIdReactionReaction404,
  PutDuckDuckIdReactionReaction409,
  PutDuckDuckIdReactionReaction500,
} from "./schemas";

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Sends a one-time password (OTP) to the user's email address for authentication
 * @summary Send OTP to user email
 */
export const postAuth = (
  authenticateRequest: AuthenticateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<PostAuth200>(
    {
      url: `/auth`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authenticateRequest,
      signal,
    },
    options,
  );
};

export const getPostAuthMutationOptions = <
  TError = PostAuth400,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuth>>,
    TError,
    { data: AuthenticateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuth>>,
  TError,
  { data: AuthenticateRequest },
  TContext
> => {
  const mutationKey = ["postAuth"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuth>>,
    { data: AuthenticateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return postAuth(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuth>>
>;
export type PostAuthMutationBody = AuthenticateRequest;
export type PostAuthMutationError = PostAuth400;

/**
 * @summary Send OTP to user email
 */
export const usePostAuth = <
  TError = PostAuth400,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuth>>,
    TError,
    { data: AuthenticateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof postAuth>>,
  TError,
  { data: AuthenticateRequest },
  TContext
> => {
  const mutationOptions = getPostAuthMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Verifies the OTP code and returns user information along with JWT token
 * @summary Verify OTP and authenticate user
 */
export const postAuthVerify = (
  authenticateRequest: AuthenticateRequest,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<AuthenticateResponse>(
    {
      url: `/auth/verify`,
      method: "POST",
      headers: { "Content-Type": "application/json" },
      data: authenticateRequest,
      signal,
    },
    options,
  );
};

export const getPostAuthVerifyMutationOptions = <
  TError = PostAuthVerify400,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthVerify>>,
    TError,
    { data: AuthenticateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postAuthVerify>>,
  TError,
  { data: AuthenticateRequest },
  TContext
> => {
  const mutationKey = ["postAuthVerify"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postAuthVerify>>,
    { data: AuthenticateRequest }
  > = (props) => {
    const { data } = props ?? {};

    return postAuthVerify(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostAuthVerifyMutationResult = NonNullable<
  Awaited<ReturnType<typeof postAuthVerify>>
>;
export type PostAuthVerifyMutationBody = AuthenticateRequest;
export type PostAuthVerifyMutationError = PostAuthVerify400;

/**
 * @summary Verify OTP and authenticate user
 */
export const usePostAuthVerify = <
  TError = PostAuthVerify400,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postAuthVerify>>,
    TError,
    { data: AuthenticateRequest },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof postAuthVerify>>,
  TError,
  { data: AuthenticateRequest },
  TContext
> => {
  const mutationOptions = getPostAuthVerifyMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Creates a new duck with image, name, email, and appearance data
 * @summary Create a new duck
 */
export const postDuck = (
  postDuckBody: PostDuckBody,
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  const formData = new FormData();
  formData.append(`image`, postDuckBody.image);
  formData.append(`name`, postDuckBody.name);
  formData.append(`email`, postDuckBody.email);
  formData.append(`appearance`, postDuckBody.appearance);

  return customInstance<DuckResponse>(
    {
      url: `/duck`,
      method: "POST",
      headers: { "Content-Type": "multipart/form-data" },
      data: formData,
      signal,
    },
    options,
  );
};

export const getPostDuckMutationOptions = <
  TError = PostDuck400 | PostDuck500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postDuck>>,
    TError,
    { data: PostDuckBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof postDuck>>,
  TError,
  { data: PostDuckBody },
  TContext
> => {
  const mutationKey = ["postDuck"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof postDuck>>,
    { data: PostDuckBody }
  > = (props) => {
    const { data } = props ?? {};

    return postDuck(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PostDuckMutationResult = NonNullable<
  Awaited<ReturnType<typeof postDuck>>
>;
export type PostDuckMutationBody = PostDuckBody;
export type PostDuckMutationError = PostDuck400 | PostDuck500;

/**
 * @summary Create a new duck
 */
export const usePostDuck = <
  TError = PostDuck400 | PostDuck500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof postDuck>>,
    TError,
    { data: PostDuckBody },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof postDuck>>,
  TError,
  { data: PostDuckBody },
  TContext
> => {
  const mutationOptions = getPostDuckMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Add a like or dislike reaction to a duck
 * @summary React to a duck
 */
export const putDuckDuckIdReactionReaction = (
  duckId: string,
  reaction: "like" | "dislike",
  options?: SecondParameter<typeof customInstance>,
) => {
  return customInstance<DuckReactionResponse>(
    { url: `/duck/${duckId}/reaction/${reaction}`, method: "PUT" },
    options,
  );
};

export const getPutDuckDuckIdReactionReactionMutationOptions = <
  TError =
    | PutDuckDuckIdReactionReaction400
    | PutDuckDuckIdReactionReaction404
    | PutDuckDuckIdReactionReaction409
    | PutDuckDuckIdReactionReaction500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
    TError,
    { duckId: string; reaction: "like" | "dislike" },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): SolidMutationOptions<
  Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
  TError,
  { duckId: string; reaction: "like" | "dislike" },
  TContext
> => {
  const mutationKey = ["putDuckDuckIdReactionReaction"];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
    { duckId: string; reaction: "like" | "dislike" }
  > = (props) => {
    const { duckId, reaction } = props ?? {};

    return putDuckDuckIdReactionReaction(duckId, reaction, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type PutDuckDuckIdReactionReactionMutationResult = NonNullable<
  Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>
>;

export type PutDuckDuckIdReactionReactionMutationError =
  | PutDuckDuckIdReactionReaction400
  | PutDuckDuckIdReactionReaction404
  | PutDuckDuckIdReactionReaction409
  | PutDuckDuckIdReactionReaction500;

/**
 * @summary React to a duck
 */
export const usePutDuckDuckIdReactionReaction = <
  TError =
    | PutDuckDuckIdReactionReaction400
    | PutDuckDuckIdReactionReaction404
    | PutDuckDuckIdReactionReaction409
    | PutDuckDuckIdReactionReaction500,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
    TError,
    { duckId: string; reaction: "like" | "dislike" },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof putDuckDuckIdReactionReaction>>,
  TError,
  { duckId: string; reaction: "like" | "dislike" },
  TContext
> => {
  const mutationOptions =
    getPutDuckDuckIdReactionReactionMutationOptions(options);

  return useMutation(() => mutationOptions);
};

/**
 * Returns a list of all ducks ordered by creation date
 * @summary Get list of ducks
 */
export const getDucks = (
  options?: SecondParameter<typeof customInstance>,
  signal?: AbortSignal,
) => {
  return customInstance<DuckResponse[]>(
    { url: `/ducks`, method: "GET", signal },
    options,
  );
};

export const getGetDucksQueryKey = () => {
  return [`/ducks`] as const;
};

export const getGetDucksQueryOptions = <
  TData = Awaited<ReturnType<typeof getDucks>>,
  TError = GetDucks500,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getDucks>>, TError, TData> & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey = queryOptions?.queryKey ?? getGetDucksQueryKey();

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getDucks>>> = ({
    signal,
  }) => getDucks(requestOptions, signal);

  return { queryKey, queryFn, ...queryOptions } ;
};

export type GetDucksQueryResult = NonNullable<
  Awaited<ReturnType<typeof getDucks>>
>;
export type GetDucksQueryError = GetDucks500;

/**
 * @summary Get list of ducks
 */

export function useGetDucks<
  TData = Awaited<ReturnType<typeof getDucks>>,
  TError = GetDucks500,
>(options?: {
  query?: UseQueryOptions<Awaited<ReturnType<typeof getDucks>>, TError, TData> & { queryKey: QueryKey };
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getGetDucksQueryOptions(options);

  const query = useQuery(() => queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}
